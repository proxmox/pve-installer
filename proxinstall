#!/usr/bin/perl -w

$ENV{DEBIAN_FRONTEND} = 'noninteractive';
$ENV{LC_ALL} = 'C';

use strict;
use Getopt::Long;
use IPC::Open2;
use IPC::Open3;
use IO::File;
use IO::Select;
use Cwd 'abs_path';
use Gtk3 '-init';
use Gtk3::WebKit;
use Encode;
use String::ShellQuote;
use Data::Dumper;
use File::Basename;

my $release = '4.0';

my $kapi = `uname -r`;
chomp $kapi;

my $opt_testmode;

if (!$ENV{G_SLICE} ||  $ENV{G_SLICE} ne "always-malloc") {
    die "do not use slice allocator (run with 'G_SLICE=always-malloc ./proxinstall ...')\n";
}

if (!GetOptions ('testmode=s' => \$opt_testmode)) {
    die "usage error\n";
    exit (-1);
}

sub file_read_firstline {
    my ($filename) = @_;

    my $fh = IO::File->new ($filename, "r");
    return undef if !$fh;
    my $res = <$fh>;
    chomp $res if $res;
    $fh->close;
    return $res;
}

my $logfd = IO::File->new (">/tmp/install.log");

my $proxmox_dir = $opt_testmode ? Cwd::cwd() : "/var/lib/pve-installer";

my $grub_plattform = "pc"; # pc, efi-amd64 or efi-ia32

$grub_plattform = "efi-amd64" if -d "/sys/firmware/efi"; 

my $IPV4OCTET = "(?:25[0-5]|(?:2[0-4]|1[0-9]|[1-9])?[0-9])";
my $IPV4RE = "(?:(?:$IPV4OCTET\\.){3}$IPV4OCTET)";
my $IPV6H16 = "(?:[0-9a-fA-F]{1,4})";
my $IPV6LS32 = "(?:(?:$IPV4RE|$IPV6H16:$IPV6H16))";

my $IPV6RE = "(?:" .
    "(?:(?:" .                             "(?:$IPV6H16:){6})$IPV6LS32)|" .
    "(?:(?:" .                           "::(?:$IPV6H16:){5})$IPV6LS32)|" .
    "(?:(?:(?:" .              "$IPV6H16)?::(?:$IPV6H16:){4})$IPV6LS32)|" .
    "(?:(?:(?:(?:$IPV6H16:){0,1}$IPV6H16)?::(?:$IPV6H16:){3})$IPV6LS32)|" .
    "(?:(?:(?:(?:$IPV6H16:){0,2}$IPV6H16)?::(?:$IPV6H16:){2})$IPV6LS32)|" .
    "(?:(?:(?:(?:$IPV6H16:){0,3}$IPV6H16)?::(?:$IPV6H16:){1})$IPV6LS32)|" .
    "(?:(?:(?:(?:$IPV6H16:){0,4}$IPV6H16)?::" .           ")$IPV6LS32)|" .
    "(?:(?:(?:(?:$IPV6H16:){0,5}$IPV6H16)?::" .            ")$IPV6H16)|" .
    "(?:(?:(?:(?:$IPV6H16:){0,6}$IPV6H16)?::" .                    ")))";

my $IPRE = "(?:$IPV4RE|$IPV6RE)";


my $ipv4_mask_hash = {
    '128.0.0.0' => 1,
    '192.0.0.0' => 2,
    '224.0.0.0' => 3,
    '240.0.0.0' => 4,
    '248.0.0.0' => 5,
    '252.0.0.0' => 6,
    '254.0.0.0' => 7,
    '255.0.0.0' => 8,
    '255.128.0.0' => 9,
    '255.192.0.0' => 10,
    '255.224.0.0' => 11,
    '255.240.0.0' => 12,
    '255.248.0.0' => 13,
    '255.252.0.0' => 14,
    '255.254.0.0' => 15,
    '255.255.0.0' => 16,
    '255.255.128.0' => 17,
    '255.255.192.0' => 18,
    '255.255.224.0' => 19,
    '255.255.240.0' => 20,
    '255.255.248.0' => 21,
    '255.255.252.0' => 22,
    '255.255.254.0' => 23,
    '255.255.255.0' => 24,
    '255.255.255.128' => 25,
    '255.255.255.192' => 26,
    '255.255.255.224' => 27,
    '255.255.255.240' => 28,
    '255.255.255.248' => 29,
    '255.255.255.252' => 30
};

my ($window, $cmdbox, $inbox, $htmlview);
my ($next, $next_fctn, $target_hd);
my ($progress, $progress_status);
my ($ipversion, $ipaddress, $ipconf_entry_addr);
my ($netmask, $ipconf_entry_mask);
my ($gateway, $ipconf_entry_gw);
my ($dnsserver, $ipconf_entry_dns);
my $hostname = 'proxmox';
my $domain = 'domain.tld';
my $cmdline = file_read_firstline("/proc/cmdline");
my $ipconf;
my $country;
my $timezone = 'Europe/Vienna';
my $password;
my $mailto;
my $keymap = 'en-us';
my $cmap;

# parse command line args

my $config_options = {};

if ($cmdline =~ m/\s(ext3|ext4|xfs|zfs)(\s.*)?$/) {
    $config_options->{filesys} = $1;
} else {
    $config_options->{filesys} = 'ext4';
}

if ($cmdline =~ m/hdsize=(\d+(\.\d+)?)[\s\n]/i) {
    $config_options->{hdsize} = $1;
}

if ($cmdline =~ m/swapsize=(\d+(\.\d+)?)[\s\n]/i) {
    $config_options->{swapsize} = $1;
}

if ($cmdline =~ m/maxroot=(\d+(\.\d+)?)[\s\n]/i) {
    $config_options->{maxroot} = $1;
}

if ($cmdline =~ m/minfree=(\d+(\.\d+)?)[\s\n]/i) {
    $config_options->{minfree} = $1;
}
 
if ($cmdline =~ m/maxvz=(\d+(\.\d+)?)[\s\n]/i) {
    $config_options->{maxvz} = $1;
}

my $postfix_main_cf = <<_EOD;
# See /usr/share/postfix/main.cf.dist for a commented, more complete version

myhostname=__FQDN__

smtpd_banner = \$myhostname ESMTP \$mail_name (Debian/GNU)
biff = no

# appending .domain is the MUA's job.
append_dot_mydomain = no

# Uncomment the next line to generate "delayed mail" warnings
#delay_warning_time = 4h

alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
mydestination = \$myhostname, localhost.\$mydomain, localhost
relayhost =
mynetworks = 127.0.0.0/8
inet_interfaces = loopback-only
recipient_delimiter = +

_EOD

sub shellquote {
    my $str = shift;

    return String::ShellQuote::shell_quote($str);
}

sub cmd2string {
    my ($cmd) = @_;

    die "no arguments" if !$cmd;

    return $cmd if !ref($cmd);

    my @qa = ();
    foreach my $arg (@$cmd) { push @qa, shellquote($arg); }

    return join (' ', @qa);
}

sub syscmd {
    my ($cmd) = @_;

    return run_command ($cmd, undef, undef, 1);
}

sub run_command {
    my ($cmd, $func, $input, $noout) = @_;

    my $cmdstr;
    if (!ref($cmd)) {
	$cmdstr = $cmd;
	if ($cmd =~ m/|/) {
	    # see 'man bash' for option pipefail
	    $cmd = [ '/bin/bash', '-c', "set -o pipefail && $cmd" ];
	} else {
	    $cmd = [ $cmd ];
	}
    } else {
	$cmdstr = cmd2string($cmd);
    }

    my $cmdtxt;
    if ($input && ($cmdstr !~ m/chpasswd/)) {
	$cmdtxt = "# $cmdstr <<EOD\n$input";
	chomp $cmdtxt;
	$cmdtxt .= "\nEOD\n";
    } else {
	$cmdtxt = "# $cmdstr\n";
    }

    if ($opt_testmode) {
	print $cmdtxt;
	STDOUT->flush();
    }

    print $logfd $cmdtxt;

    my $reader = IO::File->new();
    my $writer = IO::File->new();
    my $error  = IO::File->new();

    my $orig_pid = $$;

    my $pid;
    eval {
	$pid = open3 ($writer, $reader, $error, @$cmd) || die $!;
    };

    my $err = $@;

    # catch exec errors
    if ($orig_pid != $$) {
	POSIX::_exit (1);
	kill ('KILL', $$);
    }

    die $err if $err;

    print $writer $input if defined $input;
    close $writer;

    my $select = new IO::Select;
    $select->add ($reader);
    $select->add ($error);

    my ($ostream, $logout) = ('', '', '');

    while ($select->count) {
	my @handles = $select->can_read (0.2);

	Gtk3::main_iteration() while Gtk3::events_pending();

	next if !scalar (@handles); # timeout

	foreach my $h (@handles) {
	    my $buf = '';
	    my $count = sysread ($h, $buf, 4096);
	    if (!defined ($count)) {
		my $err = $!;
		kill (9, $pid);
		waitpid ($pid, 0);
		die "command '$cmd' failed: $err";
	    }
	    $select->remove ($h) if !$count;
	    if ($h eq $reader) {
		$ostream .= $buf if !($noout || $func);
		$logout .= $buf;
		while ($logout =~ s/^([^\010\r\n]*)(\r|\n|(\010)+|\r\n)//s) {
		    my $line = $1;
		    &$func($line) if $func;
		}

	    } elsif ($h eq $error) {
		$ostream .= $buf if !($noout || $func);
	    }
	    print $buf;
	    STDOUT->flush();
	    print $logfd $buf;
	}
    }

    &$func($logout) if $func;

    my $rv = waitpid ($pid, 0);

    return $? if $noout; # behave like standard system();

    my $ec = ($? >> 8);

    if ($ec) {
	die "command '$cmdstr' failed with exit code $ec";
    }

    return $ostream;
}

sub detect_country {

    print "trying to detect country...\n";
    my $cpid = open2(\*TMP, undef, "traceroute -N 1 -q 1 -n 8.8.8.8");
    return undef if !$cpid;

    my $country;

    my $previous_alarm = alarm (10);
    eval  {
	local $SIG{ALRM} = sub { die "timed out!\n" };
	my $line;
	while (defined ($line = <TMP>)) {
	    print $logfd "DC TRACEROUTE: $line";
	    if ($line =~ m/\s*\d+\s+(\d+\.\d+\.\d+\.\d+)\s/) {
		my $geoip = `geoiplookup $1`;
		print $logfd "DC GEOIP: $geoip";
		if ($geoip =~ m/GeoIP Country Edition:\s*([A-Z]+),/) {
		    $country = lc ($1);
		    print $logfd "DC FOUND: $country\n";
		    last;
		}
	    }
	}
    };

    my $err = $@;

    alarm ($previous_alarm);

    close (TMP);

    if ($err) {
	print "unable to detect country - $err\n";
    } elsif ($country) {
	print "detected country: " . uc($country) . "\n";
    } else {
	print "unable to detect country\n";
    }

    return $country;
}

sub get_memtotal {

    open (MEMINFO, "/proc/meminfo");

    my $res = 512; # default to 512 if something goes wrong
    while (my $line = <MEMINFO>) {
	if ($line =~ m/^MemTotal:\s+(\d+)\s*kB/i) {
	    $res = int ($1 / 1024);
	}
    }

    close (MEMINFO);

    return $res;
}

my $total_memory = get_memtotal();

sub link_points_to {
    my ($src, $dest) = @_;

    my ($dev1,$ino1) = stat ($src);
    my ($dev2,$ino2) = stat ($dest);

    return 0 if !($dev1 && $dev2 && $ino1 && $ino2);

    return $ino1 == $ino2 && $dev1 == $dev2;
}

sub find_stable_path {
    my ($stabledir, $bdev) = @_;

    foreach my $path (<$stabledir/*>) {
	if (link_points_to ($path, $bdev)) {
	    return wantarray ? ($path, basename($path)) : $path;
	}
    }
}

sub find_dev_by_uuid {
    my $bdev = shift;

    my ($full_path, $name) = find_stable_path ("/dev/disk/by-uuid", $bdev);

    return $name;
}

sub hd_list {

    my $res = ();

    if ($opt_testmode) {
	push @$res, [-1, $opt_testmode, int((-s $opt_testmode)/512), "TESTDISK"];
    }

    my $count = 0;

    foreach my $bd (</sys/block/*>) {
	next if $bd =~ m|^/sys/block/ram\d+$|;
	next if $bd =~ m|^/sys/block/loop\d+$|;
	next if $bd =~ m|^/sys/block/md\d+$|;
	next if $bd =~ m|^/sys/block/dm-.*$|;
	next if $bd =~ m|^/sys/block/fd\d+$|;
	next if $bd =~ m|^/sys/block/sr\d+$|;

	my $dev = file_read_firstline("$bd/dev");
	chomp $dev;

	next if !$dev;

	my $info = `udevadm info --path $bd --query all`;
	next if !$info;

	next if $info !~ m/^E: DEVTYPE=disk$/m;

	next if $info =~ m/^E: ID_CDROM/m;

	my ($name) = $info =~ m/^N: (\S+)$/m;

	if ($name) {
	    my $real_name = "/dev/$name";

	    my $size = file_read_firstline("$bd/size");
	    chomp $size;
	    $size = undef if !($size && $size =~ m/^\d+$/);

	    my $model = file_read_firstline("$bd/device/model") || '';
	    $model =~ s/^\s+//;
	    $model =~ s/\s+$//;
	    if (length ($model) > 30) {
		$model = substr ($model, 0, 30);
	    }
	    push @$res, [$count++, $real_name, $size, $model] if $size;
	} else {
	    print STDERR "ERROR: unable to map device $dev ($bd)\n";
	}
    }

    return $res;
}

sub read_cmap {
    my $countryfn = $opt_testmode ? "/usr/share/pve-manager/country.dat" :
	"/proxmox/country.dat";
    open (TMP, "<$countryfn") || die "unable to open '$countryfn' - $!\n";
    my $line;
    my $country = {};
    my $countryhash = {};
    my $kmap = {};
    my $kmaphash = {};
    while (defined ($line = <TMP>)) {
	if ($line =~ m|^map:([^\s:]+):([^:]+):([^:]+):([^:]+):([^:]+):([^:]*):$|) {
	    $kmap->{$1} = {
		name => $2,
		kvm => $3,
		console => $4,
		x11 => $5,
		x11var => $6,
	    };
	    $kmaphash->{$2} = $1;
	} elsif ($line =~ m|^([a-z]{2}):([^:]+):([^:]*):([^:]*):$|) {
	    $country->{$1} = {
		name => $2,
		kmap => $3,
		mirror => $4,
	    };
	    $countryhash->{lc($2)} = $1;
	} else {
	    warn "unable to parse 'country.dat' line: $line";
	}
    }
    close (TMP);

    my $zones = {};
    my $cczones = {};
    my $zonefn = "/usr/share/zoneinfo/zone.tab";
    open (TMP, "<$zonefn") || die "unable to open '$zonefn' - $!\n";
    while (defined ($line = <TMP>)) {
	next if $line =~ m/^\#/;
	next if $line =~ m/^\s*$/;
	if ($line =~ m|^([A-Z][A-Z])\s+\S+\s+(([^/]+)/\S+)\s|) {
	    my $cc = lc($1);
	    $cczones->{$cc}->{$2} = 1;
	    $country->{$cc}->{zone} = $2 if !defined ($country->{$cc}->{zone});
	    $zones->{$2} = 1;

	}
    }
    close (TMP);

    return {
	zones => $zones,
	cczones => $cczones,
	country => $country,
	countryhash => $countryhash,
	kmap => $kmap,
	kmaphash => $kmaphash,
    }
}

# search for Harddisks
my $hds = hd_list ();

sub hd_size {
    my ($dev) = @_;

    foreach my $hd (@$hds) {
	my ($disk, $devname, $size, $model) = @$hd;
	return int($size/2) if $devname eq $dev;
    }

    die "no such device '$dev'";
}

sub get_partition_dev {
    my ($dev, $partnum) = @_;

    if ($dev =~ m|^/dev/[hxsev]d[a-z]$|) {
	return "${dev}$partnum";
    } elsif ($dev =~ m|^/dev/[^/]+/c\d+d\d+$|) {
	return "${dev}p$partnum";
    } elsif ($dev =~ m|^/dev/[^/]+/d\d+$|) {
	return "${dev}p$partnum";
    } elsif ($dev =~ m|^/dev/[^/]+/hd[a-z]$|) {
	return "${dev}$partnum";
    } else {
	die "unable to get device for partition $partnum on device $dev\n";
    }

}

sub file_get_contents {
    my ($filename, $max) = @_;

    my $fh = IO::File->new($filename, "r") ||
	die "can't open '$filename' - $!\n";

    local $/; # slurp mode

    my $content = <$fh>;

    close $fh;

    return $content;
}

sub write_config {
    my ($text, $filename) = @_;

    my $fd = IO::File->new (">$filename") ||
	die "unable to open file '$filename' - $!";
    print $fd $text;
    $fd->close();
}

sub update_progress {
    my ($frac, $start, $end, $text) = @_;

    my $part = $end - $start;
    my $res = $start + $frac*$part;

    $progress->set_fraction ($res);
    $progress->set_text (sprintf ("%d%%", int ($res*100)));
    $progress_status->set_text ($text) if defined ($text);

    Gtk3::main_iteration() while Gtk3::events_pending();
}

my $fssetup = {
    ext3 => {
	mkfs => 'mkfs.ext3 -F',
	mkfs_root_opt => '',
	mkfs_data_opt => '-m 0',
	root_mountopt => 'errors=remount-ro',
    },
    ext4 => {
	mkfs => 'mkfs.ext4 -F',
	mkfs_root_opt => '',
	mkfs_data_opt => '-m 0',
	root_mountopt => 'errors=remount-ro',
    },
    xfs => {
	mkfs => 'mkfs.xfs -f',
	mkfs_root_opt => '',
	mkfs_data_opt => '',
	root_mountopt => '',
    },
};

sub create_filesystem {
    my ($dev, $name, $type, $start, $end, $fs, $fe) = @_;

    my $range = $end - $start;
    my $rs = $start + $range*$fs;
    my $re = $start + $range*$fe;
    my $max = 0;

    my $fsdata = $fssetup->{$type} || die "internal error - unknown file system '$type'";
    my $opts = $name eq 'root' ? $fsdata->{mkfs_root_opt} : $fsdata->{mkfs_data_opt};
    
    update_progress (0, $rs, $re, "creating $name filesystem");

    run_command ("$fsdata->{mkfs} $opts $dev", sub {
	my $line = shift;

	if ($line =~ m/Writing inode tables:\s+(\d+)\/(\d+)/) {
	    $max = $2;
	} elsif ($max && $line =~ m/(\d+)\/$max/) {
	    update_progress (($1/$max)*0.9, $rs, $re);
	} elsif ($line =~ m/Creating journal.*done/) {
	    update_progress (0.95, $rs, $re);
	} elsif ($line =~ m/Writing superblocks and filesystem.*done/) {
	    update_progress (1, $rs, $re);
	}
    });
}

sub debconfig_set {
    my ($targetdir, $dcdata) = @_;

    my $cfgfile = "/tmp/debconf.txt";
    write_config ($dcdata, "$targetdir/$cfgfile");
    syscmd ("chroot $targetdir debconf-set-selections $cfgfile");
    unlink "$targetdir/$cfgfile";
}

sub diversion_add {
    my ($targetdir, $cmd, $new_cmd) = @_;

    syscmd ("chroot $targetdir dpkg-divert --package proxmox " .
	    "--add --rename $cmd") == 0 ||
	    die "unable to exec dpkg-divert\n";

    syscmd ("ln -sf ${new_cmd} $targetdir/$cmd") == 0 ||
	die "unable to link diversion to ${new_cmd}\n";
}

sub diversion_remove {
    my  ($targetdir, $cmd) = @_;

    syscmd ("mv $targetdir/${cmd}.distrib $targetdir/${cmd};") == 0 ||
	die "unable to remove $cmd diversion\n";

    syscmd ("chroot $targetdir dpkg-divert --remove $cmd") == 0 ||
	die "unable to remove $cmd diversion\n";
}

sub zfs_create_rpool {
    my ($zfspoolname, $vdev) = @_;

   syscmd ("zpool create -f -o ashift=12 -o cachefile=none $zfspoolname $vdev") == 0 ||
	die "unable to create zfs root pool\n";

    syscmd ("zfs create $zfspoolname/ROOT")  == 0 ||
	die "unable to create zfs $zfspoolname/ROOT volume\n";
    
    syscmd ("zfs create $zfspoolname/ROOT/pve-1")  == 0 ||
	die "unable to create zfs $zfspoolname/ROOT/pve-1 volume\n";

    # disable atime during insatll
    syscmd ("zfs set atime=off $zfspoolname") == 0 ||
	die "unable to set zfs properties\n";
    syscmd ("zfs set compression=lz4 $zfspoolname") == 0 ||
	die "unable to set zfs properties\n";
}

sub zfs_create_swap {
    my ($zfspoolname, $swapsize) = @_;

    syscmd ("zfs create -V ${swapsize}K -b 4K $zfspoolname/swap")  == 0 ||
	die "unable to create zfs swap device\n";

    syscmd ("zfs set com.sun:auto-snapshot=false $zfspoolname/swap") == 0 ||
	die "unable to set zfs properties\n";

    # reduces memory pressure
    syscmd ("zfs set sync=always $zfspoolname/swap") == 0 ||
	die "unable to set zfs properties\n";

    return "/dev/zvol/$zfspoolname/swap";
}

sub partition_bootable_disk {
    my ($target_dev, $maxhdsize, $use_zfs) = @_;

    die "too dangerous" if $opt_testmode;

    syscmd("sgdisk -Z ${target_dev}");
    my $hdsize = hd_size($target_dev); # size in blocks (1024 bytes)

    if ($maxhdsize && ($maxhdsize < $hdsize)) {
	$hdsize = $maxhdsize;
    }

    my $hdgb = int($hdsize/(1024*1024));
    die "hardisk '$target_dev' too small (${hdsize}GB)" if $hdgb < 8;

    # 1 - GRUB boot partition: 1M 
    # 2 - EFI ESP: 128M 
    # 3 - OS/Data partition

    my $grubbootdev = get_partition_dev($target_dev, 1);
    my $efibootdev = get_partition_dev($target_dev, 2);
    my $osdev = get_partition_dev ($target_dev, 3);

    my $hdsize_mb = $hdsize/1024;

    my $pcmd = ['sgdisk', '-a1'];

    my $pnum = 1;
    push @$pcmd, "-n$pnum:34:2047", "-t$pnum:EF02";

    $pnum = 3;
    # Note: from 128M to end
    push @$pcmd, "-n$pnum:128M:0", "-t$pnum:8E00";

    
    $pnum = 2;
    # Note: from sector 2048 to 128M (0 mean till next partition)
    push @$pcmd, "-n$pnum:2048:0", "-t$pnum:EF00";
    
    push @$pcmd, $target_dev;

    my $os_size = $hdsize - 128*1024;

    syscmd($pcmd) == 0 ||
	die "unable to partition harddisk '${target_dev}'\n";

    return ($os_size, $osdev, $efibootdev);
}

# ZFS has this use_whole_disk concept, so we try to partition the same
# way as zfs does by default. There is room at start of disk to insert
# a grub boot partition. But adding a EFI ESP is not possible.  
#
# Note: zfs people think this is just a waste of space an not
# required.  Instead, you should put the ESP on another disk (log,
# ..).

sub partition_bootable_zfs_disk {
    my ($target_dev) = @_;

    die "too dangerous" if $opt_testmode;

    syscmd("sgdisk -Z ${target_dev}");
    my $hdsize = hd_size($target_dev); # size in blocks (1024 bytes)

    my $hdgb = int($hdsize/(1024*1024));
    die "hardisk '$target_dev' too small (${hdsize}GB)" if $hdgb < 8;

    # 1 - GRUB boot partition: 1M 
    # 2 - OS/Data partition
    # 9 - ZFS reserved partition

    my $grubbootdev = get_partition_dev($target_dev, 1);
    my $osdev = get_partition_dev ($target_dev, 2);

    my $pcmd = ['sgdisk', '-a1'];

    my $pnum = 1;
    push @$pcmd, "-n$pnum:34:2047", "-t$pnum:EF02";

    $pnum = 9;
    push @$pcmd, "-n$pnum:-8M:0", "-t$pnum:BF07";

    $pnum = 2;
    push @$pcmd, "-n$pnum:2048:0", "-t$pnum:BF01", '-c', "$pnum:zfs";
   
    push @$pcmd, $target_dev;
	
    my $os_size = $hdsize - 1024 - 1024*8;

    syscmd($pcmd) == 0 ||
	die "unable to partition harddisk '${target_dev}'\n";

    return ($os_size, $osdev);
}

sub create_lvm_volumes {
    my ($lvmdev, $os_size, $swap_size) = @_;

    my $rootdev = '/dev/pve/root';
    my $datadev = '/dev/pve/data';
    my $swapfile = '/dev/pve/swap';

    # we use --metadatasize 250k, which reseults in "pe_start = 512"
    # so pe_start is aligned on a 128k boundary (advantage for SSDs)
    syscmd ("/sbin/pvcreate --metadatasize 250k -y -ff $lvmdev") == 0 ||
	die "unable to initialize physical volume $lvmdev";
    syscmd ("/sbin/vgcreate pve $lvmdev") == 0 ||
	die "unable to create volume group";

    my $hdgb = int($os_size/(1024*1024));
    my $space = (($hdgb > 128) ? 16 : ($hdgb/8))*1024*1024;

    my $maxroot;
    if ($config_options->{maxroot}) {
	$maxroot = $config_options->{maxroot};
    } else {
	$maxroot = 96;
    }

    my $rootsize = (($hdgb > ($maxroot*4)) ? $maxroot : $hdgb/4)*1024*1024;

    my $rest = $os_size - $swap_size - $rootsize; # in KB

    my $minfree;
    if ($config_options->{minfree}) {
	$minfree = (($config_options->{minfree}*1024*1024) >= $rest ) ? $space : 
	    $config_options->{minfree}*1024*1024 ;
    } else {
	$minfree = $space;
    }

    $rest = $rest - $minfree;

    if ($config_options->{maxvz}) {
	$rest = (($config_options->{maxvz}*1024*1024) <= $rest) ? 
	    $config_options->{maxvz}*1024*1024 : $rest;
    }

    syscmd ("/sbin/lvcreate -L${swap_size}K -nswap pve") == 0 ||
	die "unable to create swap volume";

    syscmd ("/sbin/lvcreate -L${rootsize}K -nroot pve") == 0 ||
	die "unable to create root volume";

    syscmd ("/sbin/lvcreate -L${rest}K -ndata pve") == 0 ||
	die "unable to create data volume";

    syscmd ("/sbin/vgchange -a y pve") == 0 ||
	die "unable to activate volume group";

    return ($rootdev, $datadev, $swapfile);
}

sub compute_swapsize {
    my ($hdsize) = @_;

    my $hdgb = int($hdsize/(1024*1024));

    my $swapsize;
    if ($config_options->{swapsize}) {
	$swapsize = $config_options->{swapsize}*1024*1024;
    } else {
	my $ss = int ($total_memory / 1024);
	$ss = 4 if $ss < 4;
	$ss = ($hdgb/8) if $ss > ($hdgb/8);
	$swapsize = $ss*1024*1024;
    }
}

sub extract_data {
    my ($tgzfile, $targetdir) = @_;

    die "target '$targetdir' does not exist\n" if ! -d  $targetdir;

    my $bootdevinfo = [];

    my $datadev;
    my $swapfile;
    my $rootdev;

    my $use_zfs;
    my $zfspoolname = $opt_testmode ? "test_rpool" : 'rpool';

    my $filesys = $config_options->{filesys};

    if ($filesys =~ m/zfs/) {
	$target_hd = undef; # do not use this config
	$use_zfs = 1;
	$targetdir = "/$zfspoolname/ROOT/pve-1";
    } else {
 	$use_zfs = 0;
    }
    
    if ($use_zfs) {
	my $i;
	for ($i = 5; $i > 0; $i--) {
	    syscmd("modprobe zfs");
	    last if -c "/dev/zfs";
	    sleep(1);
	}

	die "unable to load zfs kernel module\n" if !$i;
    }

    eval {


	my $maxper = 0.25;

	update_progress (0, 0, $maxper, "create partitions");

	if ($opt_testmode) {

	    $rootdev = abs_path($target_hd);
	    syscmd ("umount $rootdev");

	    if ($use_zfs) {

		die "unsupported zfs mode (for testing environment)\n" 
		    if $filesys ne 'zfs (RAID0)';

		syscmd ("zpool destroy $zfspoolname") if $opt_testmode;

		zfs_create_rpool($zfspoolname, $rootdev);
	    }

	} elsif ($use_zfs) {

	    my ($devlist, $bootdevlist, $vdev) = get_zfs_raid_setup();

	    my $disksize;
	    foreach my $hd (@$bootdevlist) {
		my $devname = @$hd[1];
		my ($size, $osdev) =
		    partition_bootable_zfs_disk($devname);
		die "unable to mirror disks with different sizes!\n" 
		    if $disksize && ($size != $disksize);
		push @$bootdevinfo, { devname => $devname, osdev => $osdev};
		$disksize = $size;
	    }

	    sleep(1); # give kernel time to reread part table

	    # trigger udev to create /dev/disk/by-uuid
	    syscmd ("udevadm trigger --subsystem-match block");
	    syscmd ("udevadm settle --timeout 10");

	    foreach my $di (@$bootdevinfo) {
		my $devname = $di->{devname};
		$di->{by_id} = find_stable_path ("/dev/disk/by-id", $devname);
	    
		# Note: using /dev/disk/by-id/ does not work for unknown reason, we get
		# cannot create 'rpool': no such pool or dataset
		#my $osdev = find_stable_path ("/dev/disk/by-id", $di->{osdev}) || $di->{osdev};

		my $osdev = $di->{osdev};
		$vdev =~ s/ $devname/ $osdev/;
	    }

	    zfs_create_rpool($zfspoolname, $vdev);
	    
	    my $swap_size = compute_swapsize($disksize);
	    $swapfile = zfs_create_swap($zfspoolname, $swap_size);

	} else {

	    die "target '$target_hd' is not a valid block device\n" if ! -b $target_hd;

	    my $maxhdsize;
	    if ($config_options->{hdsize}) {
		# max hdsize passed on cmdline (GB)
		$maxhdsize = $config_options->{hdsize}*1024*1024;
	    }

	    my ($os_size, $osdev, $efidev); 
	    ($os_size, $osdev, $efidev) = 
		partition_bootable_disk($target_hd, $maxhdsize);
	    
	    sleep(1); # give kernel time to reread part table

	    # trigger udev to create /dev/disk/by-uuid
	    syscmd ("udevadm trigger --subsystem-match block");
	    syscmd ("udevadm settle --timeout 10");

	    my $by_id = find_stable_path ("/dev/disk/by-id", $target_hd);
	    push @$bootdevinfo, { esp => $efidev, devname => $target_hd, 
				  osdev => $osdev, by_id => $by_id };

	    my $swap_size = compute_swapsize($os_size);
	    ($rootdev, $datadev, $swapfile) = 
		create_lvm_volumes($osdev, $os_size, $swap_size);

	    # trigger udev to create /dev/disk/by-uuid
	    syscmd ("udevadm trigger --subsystem-match block");
	    syscmd ("udevadm settle --timeout 10");
	}

	if ($use_zfs) {
	    # to be fast during installation
	    syscmd ("zfs set sync=disabled $zfspoolname") == 0 ||
		die "unable to set zfs properties\n";
	}

	update_progress (0.03, 0, $maxper, "create swap space");
	if ($swapfile) {
	    syscmd ("mkswap -f $swapfile") == 0 ||
		die "unable to create swap space\n";
	}

	update_progress (0.05, 0, $maxper, "creating filesystems");

	foreach my $di (@$bootdevinfo) {
	    next if !$di->{esp};
	    syscmd ("mkfs.vfat -F32 $di->{esp}") == 0 || 
		die "unable to initialize EFI ESP on device $di->{esp}\n";
	}

	if (!$use_zfs) {

	    if ( -b $target_hd) {

		create_filesystem ($rootdev, 'root', $filesys, 0.05, $maxper, 0, 0.5);
		create_filesystem ($datadev, 'data', $filesys, 0.05, $maxper, 0.5, 1);

	    } else {

		create_filesystem ($rootdev, 'root', $filesys, 0.05, $maxper, 0, 1);
	    }
	}

	update_progress (1, 0.05, $maxper, "mounting target $rootdev");

	if (!$use_zfs) {
	    syscmd ("mount -n $rootdev -o noatime,barrier=0 $targetdir") == 0 ||
		die "unable to mount $rootdev\n";
	}

	mkdir "$targetdir/boot";
	mkdir "$targetdir/boot/efi";

	if ($datadev) {

	    mkdir "$targetdir/var";
	    mkdir "$targetdir/var/lib";
	    mkdir "$targetdir/var/lib/vz";
	    syscmd ("mount -n $datadev $targetdir/var/lib/vz") == 0 ||
		die "unable to mount $datadev\n";
	}

	display_html ("extract2-rulesystem.htm");
	update_progress (1, 0.05, $maxper, "extracting base system");

	my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size) = stat ($tgzfile);
	$ino || die "unable to open file '$tgzfile' - $!\n";

	my $files;
	if ($opt_testmode) {
	    $files = file_read_firstline("/pve/$release/install/pve-base.cnt");
	} else {
	    $files = file_read_firstline("/proxmox/pve-base.cnt");
	}

	my $per = 0;
	my $count = 0;

	run_command ("tar xvf $tgzfile -C $targetdir", sub {
	    my $line = shift;
	    $count++;
	    my $nper = int (($count *100)/$files);
	    if ($nper != $per) {
		$per = $nper;
		my $frac = $per > 100 ? 100 : $per/100;
		update_progress ($frac, $maxper, 0.5);
	    }
	});

	syscmd ("mount -n -t tmpfs tmpfs $targetdir/tmp") == 0 ||
	    die "unable to mount tmpfs on $targetdir/tmp\n";
	syscmd ("mount -n -t proc proc $targetdir/proc") == 0 ||
	    die "unable to mount proc on $targetdir/proc\n";
	syscmd ("mount -n -t sysfs sysfs $targetdir/sys") == 0 ||
	    die "unable to mount sysfs on $targetdir/sys\n";

	display_html ("extract3-spam.htm");
	update_progress (1, $maxper, 0.5, "configuring base system");

	# configure hosts

	my $hosts =
	    "127.0.0.1 localhost.localdomain localhost\n" .
	    "$ipaddress $hostname.$domain $hostname pvelocalhost\n\n" .
	    "# The following lines are desirable for IPv6 capable hosts\n\n" .
	    "::1     ip6-localhost ip6-loopback\n" .
	    "fe00::0 ip6-localnet\n" .
	    "ff00::0 ip6-mcastprefix\n" .
	    "ff02::1 ip6-allnodes\n" .
	    "ff02::2 ip6-allrouters\n" .
	    "ff02::3 ip6-allhosts\n";

	write_config ($hosts, "$targetdir/etc/hosts");

	write_config ("$hostname\n", "$targetdir/etc/hostname");

	syscmd ("/bin/hostname $hostname") if !$opt_testmode;

	# configure interfaces

	my $ifaces = "auto lo\niface lo inet loopback\n\n";

	my $ntype = $ipversion == 4 ? 'inet' : 'inet6';

	 $ifaces .=
	     "auto vmbr0\niface vmbr0 $ntype static\n" .
	     "\taddress $ipaddress\n" .
	     "\tnetmask $netmask\n" .
	     "\tgateway $gateway\n" .
	     "\tbridge_ports eth0\n" .
	     "\tbridge_stp off\n" .
	     "\tbridge_fd 0\n";

	write_config ($ifaces, "$targetdir/etc/network/interfaces");

	# configure dns

	my $resolfconf = "search $domain\nnameserver $dnsserver\n";
	write_config ($resolfconf, "$targetdir/etc/resolv.conf");

	# configure fstab

	my $fstab = "# <file system> <mount point> <type> <options> <dump> <pass>\n";

	if (!$use_zfs) {
	    my $root_mountopt = $fssetup->{$filesys}->{root_mountopt} || 'defaults';
	    $fstab .= "$rootdev / $filesys ${root_mountopt} 0 1\n";
	    $fstab .= "$datadev /var/lib/vz $filesys defaults 0 1\n" if $datadev;
	}

	# mount /boot/efi
	# Note: this is required by current grub, but really dangerous, because
	# vfat does not have journaling, so it triggers manual fsck after each crash
	# so we only mount /boot/efi if really required (efi systems).
	if ($grub_plattform =~ m/^efi-/) {
	    if (scalar(@$bootdevinfo)) {
		my $di = @$bootdevinfo[0]; # simply use first disk
		if ($di->{esp}) {
		    my $efi_boot_uuid = $di->{esp};
		    if (my $uuid = find_dev_by_uuid ($di->{esp})) {
			$efi_boot_uuid = "UUID=$uuid";
		    }
	    
		    $fstab .= "${efi_boot_uuid} /boot/efi vfat defaults 0 1\n";
		}
	    }
	}


	$fstab .= "$swapfile none swap sw 0 0\n" if $swapfile;

	$fstab .= "proc /proc proc defaults 0 0\n";

	write_config ($fstab, "$targetdir/etc/fstab");
	write_config ("", "$targetdir/etc/mtab");

	syscmd ("cp ${proxmox_dir}/policy-disable-rc.d " .
		"$targetdir/usr/sbin/policy-rc.d") == 0 ||
		die "unable to copy policy-rc.d\n";
	syscmd ("cp ${proxmox_dir}/fake-start-stop-daemon " .
		"$targetdir/sbin/") == 0 ||
		die "unable to copy start-stop-daemon\n";

	diversion_add ($targetdir, "/sbin/start-stop-daemon", "/sbin/fake-start-stop-daemon");
	diversion_add ($targetdir, "/usr/sbin/update-grub", "/bin/true");
	diversion_add ($targetdir, "/usr/sbin/update-initramfs", "/bin/true");

	syscmd ("touch  $targetdir/proxmox_install_mode");

	my $grub_install_devices_txt = '';
	foreach my $di (@$bootdevinfo) {
	    $grub_install_devices_txt .= ', ' if $grub_install_devices_txt;
	    $grub_install_devices_txt .= $di->{by_id} || $di->{devname};
	}

	# Note: debian-installer/locale is used by console-setup
	
	debconfig_set ($targetdir, <<_EOD);
locales locales/default_environment_locale select en_US.UTF-8
locales locales/locales_to_be_generated select en_US.UTF-8 UTF-8
samba-common samba-common/dhcp boolean false
samba-common samba-common/workgroup string WORKGROUP
postfix postfix/main_mailer_type select Local only
keyboard-configuration keyboard-configuration/xkb-keymap select $keymap
d-i debian-installer/locale select en_US.UTF-8
grub-pc grub-pc/install_devices select $grub_install_devices_txt
_EOD

	my $pkgdir = $opt_testmode ? "packages" : "/proxmox/packages";
	my $pkg_count = 0;
	while (<$pkgdir/*.deb>) { $pkg_count++ };

	$count = 0;
	while (<$pkgdir/*.deb>) {
	    chomp;
	    my $path = $_;
	    my ($deb) = $path =~ m/$pkgdir\/(.*\.deb)/;
#	    if ($deb =~ m/^grub-efi-/ && $deb !~ m/^grub-${grub_plattform}/) {
#		$count++;
#		next;
#	    }
	    update_progress ($count/$pkg_count, 0.5, 0.75, "extracting $deb");
	    print "extracting: $deb\n";
	    syscmd ("cp $path $targetdir/tmp/$deb") == 0 ||
		die "installation of package $deb failed\n";
	    syscmd ("chroot $targetdir dpkg --force-depends --no-triggers --unpack /tmp/$deb") == 0 ||
		die "installation of package $deb failed\n";
	    update_progress ((++$count)/$pkg_count, 0.5, 0.75);
	}

	display_html ("extract4-virus.htm");

	my $cmd = "chroot $targetdir dpkg --force-confold --configure -a";
	$count = 0;
	run_command ($cmd, sub {
	    my $line = shift;
	    if ($line =~ m/Setting up\s+(\S+)/) {
		update_progress ((++$count)/$pkg_count, 0.75, 0.95,
				 "configuring $1");
	    }
	});

	debconfig_set ($targetdir, <<_EOD);
postfix postfix/main_mailer_type select No configuration
_EOD

	unlink "$targetdir/etc/mailname";
	$postfix_main_cf =~ s/__FQDN__/${hostname}.${domain}/;
	write_config ($postfix_main_cf, "$targetdir/etc/postfix/main.cf");

	# make sure we have all postfix directories
	syscmd ("chroot $targetdir /usr/sbin/postfix check");
	# cleanup mail queue
	syscmd ("chroot $targetdir /usr/sbin/postsuper -d ALL");

	# enable NTP (timedatectl set-ntp true  does not work without DBUS)
	syscmd ("chroot $targetdir /bin/systemctl enable systemd-timesyncd.service");

	unlink  "$targetdir/proxmox_install_mode";

	# set timezone
	unlink ("$targetdir/etc/localtime");
	symlink ("/usr/share/zoneinfo/$timezone", "$targetdir/etc/localtime");
	write_config ("$timezone\n", "$targetdir/etc/timezone");

	# set apt mirror
	if (my $mirror = $cmap->{country}->{$country}->{mirror}) {
	    my $fn = "$targetdir/etc/apt/sources.list";
	    syscmd ("sed -i 's/ftp\\.debian\\.org/$mirror/' '$fn'");
	}

	# create extended_states for apt (avoid cron job warning if that
	# file does not exist)
	write_config ('', "$targetdir/var/lib/apt/extended_states");

	# allow ssh root login
	syscmd ("sed -i 's/^PermitRootLogin.*/PermitRootLogin yes/' '$targetdir/etc/ssh/sshd_config'");
	
	# save installer settings
	my $ucc = uc ($country);
	debconfig_set ($targetdir, <<_EOD);
pve-manager pve-manager/country string $ucc
_EOD

	update_progress (0.8, 0.95, 1, "make system bootable");

	if ($use_zfs) {
	    syscmd ("sed -i -e 's/^GRUB_CMDLINE_LINUX=.*/GRUB_CMDLINE_LINUX=\"root=ZFS=$zfspoolname\\/ROOT\\/pve-1 boot=zfs\"/' $targetdir/etc/default/grub") == 0 ||
		die "unable to update /etc/default/grub\n";
   
	}

	diversion_remove ($targetdir, "/usr/sbin/update-grub");
	diversion_remove ($targetdir, "/usr/sbin/update-initramfs");

	if (!$opt_testmode) {

	    unlink ("$targetdir/etc/mtab");
	    symlink ("/proc/mounts", "$targetdir/etc/mtab");
	    syscmd ("mount -n --bind /dev $targetdir/dev");

	    syscmd ("chroot $targetdir /usr/sbin/update-initramfs -c -k $kapi") == 0 ||
		die "unable to install initramfs\n";

	    foreach my $di (@$bootdevinfo) {
		my $dev = $di->{devname};
		syscmd ("chroot $targetdir /usr/sbin/grub-install --target i386-pc --no-floppy --bootloader-id='proxmox' $dev") == 0 ||
			die "unable to install the i386-pc boot loader on '$dev'\n";

		if ($di->{esp}) {
		    syscmd ("mount -n $di->{esp} $targetdir/boot/efi") == 0 ||
			die "unable to mount $di->{esp}\n";
		    syscmd ("chroot $targetdir /usr/sbin/grub-install --target x86_64-efi --no-floppy --bootloader-id='proxmox' $dev") == 0 ||
			die "unable to install the EFI boot loader on '$dev'\n";
		    syscmd ("umount $targetdir/boot/efi") == 0 ||
			die "unable to umount $targetdir/boot/efi\n";
		}
	    }

	    syscmd ("chroot $targetdir /usr/sbin/update-grub") == 0 ||
		die "unable to update boot loader config\n";

	    syscmd ("umount $targetdir/dev");
	}

	# cleanup

	# hack: remove dead.letter from sshd installation
	syscmd ("rm -rf $targetdir/dead.letter");

	unlink "$targetdir/usr/sbin/policy-rc.d";

	diversion_remove ($targetdir, "/sbin/start-stop-daemon");

	# set root password
	my $octets = encode("utf-8", $password);
	run_command ("chroot $targetdir /usr/sbin/chpasswd", undef,
		     "root:$octets\n");

	# create pmxcfs DB

	my $tmpdir = "$targetdir/tmp/pve";
	mkdir $tmpdir;

	# write vnc keymap to datacenter.cfg
	my $vnckmap = $cmap->{kmap}->{$keymap}->{kvm} || 'en-us';
	write_config ("keyboard: $vnckmap\n",
		      "$tmpdir/datacenter.cfg");

	# save admin email
	write_config ("user:root\@pam:1:0:::${mailto}::\n",
		      "$tmpdir/user.cfg");

	run_command("chroot $targetdir /usr/bin/create_pmxcfs_db /tmp/pve /var/lib/pve-cluster/config.db");

	syscmd ("rm -rf $tmpdir");
    };

    my $err = $@;

    update_progress (1, 0, 1, "");

    print $err if $err;

    if ($opt_testmode) {
	syscmd ("chroot $targetdir /usr/bin/dpkg-query -W --showformat='\${package}\n'> pve-final.pkglist");
    }

    syscmd ("umount $targetdir/var/lib/vz");
    syscmd ("umount $targetdir/tmp");
    syscmd ("umount $targetdir/proc");
    syscmd ("umount $targetdir/sys");

    if ($use_zfs) {
	syscmd ("zfs umount -a") == 0 ||
	    die "unable to unmount zfs\n";
    } else {
	syscmd ("umount -d $targetdir");
    }

    if (!$err && $use_zfs) {
	syscmd ("zfs set sync=standard $zfspoolname") == 0 ||
	    die "unable to set zfs properties\n";

	syscmd ("zfs set mountpoint=/ $zfspoolname/ROOT/pve-1") == 0 ||
	    die "zfs set mountpoint failed\n";
	    
	syscmd ("zpool set bootfs=$zfspoolname/ROOT/pve-1 $zfspoolname")  == 0 ||
	    die "zfs set bootfs failed\n";
    }

    die $err if $err;
}

sub display_html {
    my ($filename) = @_;

    my $path = "${proxmox_dir}/html/$filename";
    my $url = "file://$path";

    my $data = file_get_contents($path);

    if ($filename eq 'license.htm') {
	my $licensefn = -f "/EULA" ? "/EULA" : 
	    $opt_testmode ? "./copyright" : 
	    "/usr/share/doc/pve-installer/copyright";
	my $license = decode('utf8', file_get_contents($licensefn));
	$license =~ m/^\s+(.+\n)/;
	my $title = $licensefn eq '/EULA' ? "END USER LICENSE AGREEMENT (EULA)": $1;
	$data =~ s/__LICENSE__/$license/;
	$data =~ s/__LICENSE_TITLE__/$title/;
    }

    $htmlview->load_html_string($data, $url);
}

sub set_next {
    my ($text, $fctn) = @_;

    $next_fctn = $fctn;
    $text = "_Next" if !$text;
    $next->set_label ($text);

    $next->grab_focus ();
}

sub url_requested {
    my ($doc, $url, $stream) = @_;

    $stream->set_cancel_func (sub {}); # hack: avoid warning

    my $path = "${proxmox_dir}/html/$url";

    if (-f $path) {
	open (HTMLTMP, $path) ||
	    die "unable to open file '$path' - $! ";
	my $buf;
	while (my $i = read (HTMLTMP, $buf, 4096)) {
	    $stream->write ($buf);
	    Gtk3::main_iteration() while Gtk3::events_pending();
	}
	close (HTMLTMP);
    }

    #$stream->close(); # hack: dont close - avoid crash
}

sub create_main_window {

    $window = Gtk3::Window->new ();
    $window->set_default_size (1024, 768);
    $window->set_has_resize_grip(0);
    $window->set_decorated (0) if !$opt_testmode;

    my $vbox = Gtk3::VBox->new (0, 0);

    my $image = Gtk3::Image->new_from_file  ("${proxmox_dir}/proxlogo.xpm");
    $vbox->pack_start ($image, 0, 0, 0);

    my $hbox = Gtk3::HBox->new (0, 0);
    $vbox->pack_start ($hbox, 1, 1, 0);

 #  my $f1 = Gtk3::Frame->new ('test');
 #  $f1->set_shadow_type ('none');
 #  $hbox->pack_start ($f1, 1, 1, 0);

    my $sep1 = Gtk3::HSeparator->new;
    $vbox->pack_start ($sep1, 0, 0, 0);

    $cmdbox = Gtk3::HBox->new ();
    $vbox->pack_start ($cmdbox, 0, 0, 10);

    $next = Gtk3::Button->new ('_Next');
    $next->signal_connect (clicked => sub { &$next_fctn (); });
    $cmdbox->pack_end ($next, 0, 0, 10);
    my $abort = Gtk3::Button->new ('_Abort');
    $abort->set_can_focus (0);
    $cmdbox->pack_start ($abort, 0, 0, 10);
    $abort->signal_connect (clicked => sub { exit (-1); });

    my $vbox2 = Gtk3::VBox->new (0, 0);
    $hbox->add ($vbox2);

    $htmlview = Gtk3::WebKit::WebView->new();
    my $scrolls = Gtk3::ScrolledWindow->new();
    $scrolls->add($htmlview);
   
    my $hbox2 = Gtk3::HBox->new (0, 0);
    $hbox2->pack_start ($scrolls, 1, 1, 0);

    $vbox2->pack_start ($hbox2, 1, 1, 0);

    my $vbox3 = Gtk3::VBox->new (0, 0);
    $vbox2->pack_start ($vbox3, 0, 0, 0);

    my $sep2 = Gtk3::HSeparator->new;
    $vbox3->pack_start ($sep2, 0, 0, 0);

    $inbox = Gtk3::HBox->new (0, 0);
    $vbox3->pack_start ($inbox, 0, 0, 0);

    $window->add ($vbox);

    $window->show_all;
    $window->realize ();
}

sub cleanup_view { 
    $inbox->foreach(sub {
	my $child = shift;
	$inbox->remove ($child);	
    });
}

# fixme: newer GTK3 has special properties to handle numbers with Entry
# only allow floating point numbers with Gtk3::Entry
sub check_float {
    my ($entry, $event) = @_;


    my $val = $event->get_keyval;

    if ($val == ord '.' ||
	$val == Gtk3::Gdk::KEY_ISO_Left_Tab ||
	$val == Gtk3::Gdk::KEY_Shift_L ||
	$val == Gtk3::Gdk::KEY_Tab ||
	$val == Gtk3::Gdk::KEY_Left ||
	$val == Gtk3::Gdk::KEY_Right ||
	$val == Gtk3::Gdk::KEY_BackSpace ||
	$val == Gtk3::Gdk::KEY_Delete ||
	($val >= ord '0' && $val <= ord '9') ||
	($val >= Gtk3::Gdk::KEY_KP_0 &&
	 $val <= Gtk3::Gdk::KEY_KP_9)) {
	return undef;
    }

    return 1;
}

sub create_text_input {
    my ($default, $text) = @_;

    my $hbox = Gtk3::HBox->new (0, 0);

    my $label = Gtk3::Label->new ($text);
    $label->set_size_request (150, -1);
    $label->set_alignment (1, 0.5);
    $hbox->pack_start ($label, 0, 0, 10);
    my $e1 = Gtk3::Entry->new ();
    $e1->set_width_chars (30);
    $hbox->pack_start ($e1, 0, 0, 0);
    $e1->set_text ($default);

    return ($hbox, $e1);
}

sub get_ip_config {

    my $ifconfig = `ifconfig eth0`;

    my ($addr) = $ifconfig =~ m/inet addr:(\S*)/m;
    my ($mask) = $ifconfig =~ m/Mask:(\S*)/m;

    my $route = `route -n`;
    my ($gateway) = $route =~ m/^0\.0\.0\.0\s+(\d+\.\d+\.\d+\.\d+)\s+/m;

    my $resolvconf = `cat /etc/resolv.conf`;
    my ($dnsserver) = $resolvconf =~ m/^nameserver\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/m;
    my ($domain) = $resolvconf =~ m/^domain\s+(\S+)$/m;

    return {
	addr => $addr,
	mask => $mask,
	gateway => $gateway,
	dnsserver => $dnsserver,
	domain => $domain,
    }
}

sub display_message {
    my ($msg) = @_;

    my $dialog = Gtk3::MessageDialog->new ($window, 'modal',
					   'info', 'ok', $msg);
    $dialog->run();
    $dialog->destroy();
}

sub display_error {
    my ($msg) = @_;

    my $dialog = Gtk3::MessageDialog->new ($window, 'modal',
					   'error', 'ok', $msg);
    $dialog->run();
    $dialog->destroy();
}

sub create_ipconf_view {

    cleanup_view ();
    display_html ("ipconf.htm");

    my $vbox =  Gtk3::VBox->new (0, 0);
    $inbox->pack_start ($vbox, 1, 0, 0);
    my $hbox =  Gtk3::HBox->new (0, 0);
    $vbox->pack_start ($hbox, 0, 0, 10);
    my $vbox2 =  Gtk3::VBox->new (0, 0);
    $hbox->add ($vbox2);

    my $addr = $ipconf->{addr} || '192.168.100.2';
    my $mask = $ipconf->{mask} || '255.255.255.0';

    my $hn = $ipconf->{domain} ? "pve.$ipconf->{domain}" : 'pve.domain.tld';
   
    my ($hostbox, $hostentry) =
	create_text_input ($hn, 'Hostname (FQDN):');
    $vbox2->pack_start ($hostbox, 0, 0, 2);

    my $ipbox;
    ($ipbox, $ipconf_entry_addr) =
	create_text_input ($addr, 'IP Address:');
    $vbox2->pack_start ($ipbox, 0, 0, 2);

    my $maskbox;
    ($maskbox, $ipconf_entry_mask) =
	create_text_input ($mask, 'Netmask:');
    $vbox2->pack_start ($maskbox, 0, 0, 2);

    $gateway = $ipconf->{gateway} || '192.168.100.1';

    my $gwbox;
    ($gwbox, $ipconf_entry_gw) =
	create_text_input ($gateway, 'Gateway:');

    $vbox2->pack_start ($gwbox, 0, 0, 2);

    $dnsserver = $ipconf->{dnsserver} || $gateway;

    my $dnsbox;
    ($dnsbox, $ipconf_entry_dns) =
	create_text_input ($dnsserver, 'DNS Server:');

    $vbox2->pack_start ($dnsbox, 0, 0, 0);

    $inbox->show_all;
    set_next (undef, sub {

	# verify hostname
	
	my $text = $hostentry->get_text();

	$text =~ s/^\s+//;
	$text =~ s/\s+$//;

	my $namere = "([a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?)";

 	if ($text && $text =~ m/^(${namere}\.)*${namere}$/ && $text !~ m/.domain.tld$/ &&
	    $text =~ m/^([^\.]+)\.(\S+)$/) {
	    $hostname = $1;
	    $domain = $2;
	} else {
	    display_message ("Hostname does not look like a fully qualified domain name.");
	    $hostentry->grab_focus();
	    return;
	}

	# verify ip address

	$text = $ipconf_entry_addr->get_text();
	$text =~ s/^\s+//;
	$text =~ s/\s+$//;
	if ($text =~ m!^($IPV4RE)$!) {
	    $ipaddress = $text;
	    $ipversion = 4;
	} elsif ($text =~ m!^($IPV6RE)$!) {
	    $ipaddress = $text; 
	    $ipversion = 6;
	} else {
	    display_message ("IP address is not valid.");
	    $ipconf_entry_addr->grab_focus();
	    return;
	}

	$text = $ipconf_entry_mask->get_text();
	$text =~ s/^\s+//;
	$text =~ s/\s+$//;
	if (($ipversion == 6) && ($text =~ m/^(\d+)$/) && ($1 >= 8) && ($1 <= 126)) {
	    $netmask = $text;
	} elsif (($ipversion == 4) && defined($ipv4_mask_hash->{$text})) {
	    $netmask = $text;
	} else {
	    display_message ("Netmask is not valid.");
	    $ipconf_entry_mask->grab_focus();
	    return;
	}

	$text = $ipconf_entry_gw->get_text();
	$text =~ s/^\s+//;
	$text =~ s/\s+$//;
	if (($ipversion == 4) && ($text =~ m!^($IPV4RE)$!)) {
	    $gateway = $text;
	} elsif (($ipversion == 6) && ($text =~ m!^($IPV6RE)$!)) {
	    $gateway = $text;
	} else {
	    display_message ("Gateway is not valid.");
	    $ipconf_entry_gw->grab_focus();
	    return;
	}
	
	$text = $ipconf_entry_dns->get_text();
	$text =~ s/^\s+//;
	$text =~ s/\s+$//;
	if (($ipversion == 4) && ($text =~ m!^($IPV4RE)$!)) {
	    $dnsserver = $text;
	} elsif (($ipversion == 6) && ($text =~ m!^($IPV6RE)$!)) {
	    $dnsserver = $text;
	} else {
	    display_message ("DNS server is not valid.");
	    $ipconf_entry_dns->grab_focus();
	    return;
	}
	
	#print "TEST $ipaddress $netmask $gateway $dnsserver\n";
	
	create_extract_view ();
    });

    $hostentry->grab_focus();
}

sub get_device_desc {
    my ($devname, $size, $model) = @_;

    if ($size && ($size > 0)) {
	$size = int($size/2048); # size in MB

	my $text = "$devname (";
	if ($size >= 1024) {
	    $size = int($size/1024); # size in GB
	    $text .= "${size}GB";
	} else {
	    $text .= "${size}MB";
	}

	$text .= ", $model" if $model;
	$text .= ")";

    } else {
	return $devname;
    }
}

sub update_layout {
    my ($cb, $kmap) = @_;

    my $ind;
    my $def;
    my $i = 0;
    my $kmaphash = $cmap->{kmaphash};
    foreach my $layout (sort keys %$kmaphash) {
	$def = $i if $kmaphash->{$layout} eq 'en-us';
	$ind = $i if $kmap && $kmaphash->{$layout} eq $kmap;
	$i++;
    }

    $cb->set_active ($ind || $def || 0);
}

my $lastzonecb;
sub update_zonelist {
    my ($box, $cc) = @_;

    my $cczones = $cmap->{cczones};
    my $zones = $cmap->{zones};

    my $sel;
    if ($lastzonecb) {
	$sel = $lastzonecb->get_active_text();
	$box->remove ($lastzonecb);
    } else {
	$sel = $timezone; # used once to select default
    }

    my $cb = $lastzonecb = Gtk3::ComboBoxText->new();
    $cb->set_size_request (200, -1);

    $cb->signal_connect ('changed' => sub {
	$timezone = $cb->get_active_text();
    });

    my @za;
    if ($cc && defined ($cczones->{$cc})) {
	@za = keys %{$cczones->{$cc}};
    } else {
	@za = keys %$zones;
    }
    my $ind;
    my $i = 0;
    foreach my $zone (sort @za) {
	$ind = $i if $sel && $zone eq $sel;
	$cb->append_text ($zone);
	$i++;
    }

    $cb->set_active ($ind || 0);

    $cb->show;
    $box->pack_start ($cb, 0, 0, 0);
}

sub create_password_view {

    cleanup_view ();

    my $vbox2 =  Gtk3::VBox->new (0, 0);
    $inbox->pack_start ($vbox2, 1, 0, 0);
    my $vbox =  Gtk3::VBox->new (0, 0);
    $vbox2->pack_start ($vbox, 0, 0, 10);

    my $hbox1 = Gtk3::HBox->new (0, 0);
    my $label = Gtk3::Label->new ("Password");
    $label->set_size_request (150, -1);
    $label->set_alignment (1, 0.5);
    $hbox1->pack_start ($label, 0, 0, 10);
    my $pwe1 = Gtk3::Entry->new ();
    $pwe1->set_visibility (0);
    $pwe1->set_size_request (200, -1);
    $hbox1->pack_start ($pwe1, 0, 0, 0);

    my $hbox2 = Gtk3::HBox->new (0, 0);
    $label = Gtk3::Label->new ("Confirm");
    $label->set_size_request (150, -1);
    $label->set_alignment (1, 0.5);
    $hbox2->pack_start ($label, 0, 0, 10);
    my $pwe2 = Gtk3::Entry->new ();
    $pwe2->set_visibility (0);
    $pwe2->set_size_request (200, -1);
    $hbox2->pack_start ($pwe2, 0, 0, 0);

    my $hbox3 = Gtk3::HBox->new (0, 0);
    $label = Gtk3::Label->new ("E-Mail");
    $label->set_size_request (150, -1);
    $label->set_alignment (1, 0.5);
    $hbox3->pack_start ($label, 0, 0, 10);
    my $eme = Gtk3::Entry->new ();
    $eme->set_size_request (200, -1);
    $hbox3->pack_start ($eme, 0, 0, 0);


    $vbox->pack_start ($hbox1, 0, 0, 5);
    $vbox->pack_start ($hbox2, 0, 0, 5);
    $vbox->pack_start ($hbox3, 0, 0, 15);

    $inbox->show_all;

    display_html ("passwd.htm");

    set_next (undef,  sub {

	my $t1 = $pwe1->get_text;
	my $t2 = $pwe2->get_text;

	if (length ($t1) < 5) {
	    display_message ("Password is too short.");
	    $pwe1->grab_focus();
	    return;
	}

	if ($t1 ne $t2) {
	    display_message ("Password does not match.");
	    $pwe1->grab_focus();
	    return;
	}

	my $t3 = $eme->get_text;
	if ($t3 !~ m/^\S+\@\S+\.\S+$/) {
	    display_message ("E-Mail does not look like a vaild address" .
			     " (user\@domain.tld)");
	    $eme->grab_focus();
	    return;

	}

	$password = $t1;
	$mailto = $t3;

	create_ipconf_view();
    });

    $pwe1->grab_focus();

}

sub create_country_view {

    cleanup_view ();

    my $countryhash = $cmap->{countryhash};
    my $ctr = $cmap->{country};

    my $vbox2 =  Gtk3::VBox->new (0, 0);
    $inbox->pack_start ($vbox2, 1, 0, 0);
    my $vbox =  Gtk3::VBox->new (0, 0);
    $vbox2->pack_start ($vbox, 0, 0, 10);

    my $w = Gtk3::Entry->new ();
    $w->set_size_request (200, -1);

    my $c = Gtk3::EntryCompletion->new ();
    $c->set_text_column (0);
    $c->set_minimum_key_length(0);
    $c->set_popup_set_width (1);
    $c->set_inline_completion (1);

    my $hbox2 = Gtk3::HBox->new (0, 0);
    my $label = Gtk3::Label->new ("Time zone");
    $label->set_size_request (150, -1);
    $label->set_alignment (1, 0.5);
    $hbox2->pack_start ($label, 0, 0, 10);
    update_zonelist ($hbox2);

    my $hbox3 = Gtk3::HBox->new (0, 0);
    $label = Gtk3::Label->new ("Keyboard Layout");
    $label->set_size_request (150, -1);
    $label->set_alignment (1, 0.5);
    $hbox3->pack_start ($label, 0, 0, 10);

    my $kmapcb = Gtk3::ComboBoxText->new();
    $kmapcb->set_size_request (200, -1);
    foreach my $layout (sort keys %{$cmap->{kmaphash}}) {
	$kmapcb->append_text ($layout);
    }

    update_layout ($kmapcb);
    $hbox3->pack_start ($kmapcb, 0, 0, 0);

    $kmapcb->signal_connect ('changed' => sub {
	my $sel = $kmapcb->get_active_text();
	if (my $kmap = $cmap->{kmaphash}->{$sel}) {
	    my $xkmap = $cmap->{kmap}->{$kmap}->{x11};
	    my $xvar = $cmap->{kmap}->{$kmap}->{x11var};
	    syscmd ("setxkbmap $xkmap $xvar") if !$opt_testmode;
	    $keymap = $kmap;
	}
    });

    $w->signal_connect ('changed' => sub {
	my ($entry, $event) = @_;
	my $text = $entry->get_text;

	if (my $cc = $countryhash->{lc($text)}) {
	    update_zonelist ($hbox2, $cc);
	    my $kmap = $ctr->{$cc}->{kmap} || 'en-us';
	    update_layout ($kmapcb, $kmap);
	}
    });

    $w->signal_connect (key_press_event => sub {
	my ($entry, $event) = @_;
	my $text = $entry->get_text;

	my $val = $event->get_keyval;

	if ($val == Gtk3::Gdk::KEY_Tab) {
	    my $cc = $countryhash->{lc($text)};
	    
	    my $found = 0;
	    my $compl;

	    if ($cc) {
		$found = 1;
		$compl = $ctr->{$cc}->{name};
	    } else {
		foreach my $cc (keys %$ctr) {
		    my $ct = $ctr->{$cc}->{name};
		    if ($ct =~ m/^\Q$text\E.*$/i) {
			$found++;
			$compl = $ct;
		    }
		    last if $found > 1;
		}
	    }

	    if ($found == 1) {
		$entry->set_text($compl);
		$c->complete();
		return undef;
	    } else {
		#Gtk3::Gdk::beep();
		print chr(7); # beep ?
	    }

	    $c->complete();

	    my $buf = $w->get_buffer();
	    $buf->insert_text(-1, '', -1); # popup selection

	    return 1;
	}

	return undef;
    });
 
    my $ls = Gtk3::ListStore->new('Glib::String');
    foreach my $cc (sort {$ctr->{$a}->{name} cmp $ctr->{$b}->{name} } keys %$ctr) {
	my $iter = $ls->append();
	$ls->set ($iter, 0, $ctr->{$cc}->{name});
    }
    $c->set_model ($ls);

    $w->set_completion ($c);

    my $hbox =  Gtk3::HBox->new (0, 0);

    $label = Gtk3::Label->new ("Country");
    $label->set_alignment (1, 0.5);
    $label->set_size_request (150, -1);
    $hbox->pack_start ($label, 0, 0, 10);
    $hbox->pack_start ($w, 0, 0, 0);

    $vbox->pack_start ($hbox, 0, 0, 5);
    $vbox->pack_start ($hbox2, 0, 0, 5);
    $vbox->pack_start ($hbox3, 0, 0, 5);

    if ($country) {
	$w->set_text ($ctr->{$country}->{name});
    }

    $inbox->show_all;

    display_html ("country.htm");
    set_next (undef,  sub {

	my $text = $w->get_text;

	if (my $cc = $countryhash->{lc($text)}) {
	    $country = $cc;
	    create_password_view();
	    return;
	} else {
	    display_message ("Please select a country first.");
	    $w->grab_focus();
	}
    });

    $w->grab_focus();
}

my $target_hd_combo;
my $target_hd_label;

my $hdopion_first_setup = 1;

sub create_hdoption_view {

    my $dialog = Gtk3::Dialog->new();

    $dialog->set_title("Harddisk options");

    $dialog->add_button("_OK", 1);

    my $contarea = $dialog->get_content_area();

    my $hbox2 =  Gtk3::Box->new('horizontal', 0);
    $contarea->pack_start($hbox2, 1, 1, 10);

    my $grid =  Gtk3::Grid->new();
    $grid->set_column_spacing(10);
    $grid->set_row_spacing(10);
    
    $hbox2->pack_start($grid, 1, 0, 10);

    my $row = 0;

    # Filesystem type

    my $label0 = Gtk3::Label->new ("Filesystem");
    $label0->set_alignment (1, 0.5);
    $grid->attach($label0, 0, $row, 1, 1);
   
    my $fstypecb = Gtk3::ComboBoxText->new();

    my $fstype = ['ext3', 'ext4', 'xfs', 'zfs (RAID0)', 'zfs (RAID1)', 
		  'zfs (RAID10)', 'zfs (RAIDZ-1)', 
		  'zfs (RAIDZ-2)', 'zfs (RAIDZ-3)'];

    my $tcount = 0;
    foreach my $tmp (@$fstype) {
	$fstypecb->append_text($tmp);
	$fstypecb->set_active ($tcount)
	    if $config_options->{filesys} eq $tmp;
	$tcount++;
    }

    $grid->attach($fstypecb, 1, $row, 1, 1);

    $hbox2->show_all();

    $row++;

    my @disk_label;
    my @disk_selector;
    for (my $i = 0; $i < 6; $i++) {
	$disk_label[$i] = Gtk3::Label->new ("Hardisk $i");
	$disk_label[$i]->set_alignment (1, 0.5);
	$grid->attach($disk_label[$i], 0, $row, 1, 1);
	$disk_selector[$i] = Gtk3::ComboBoxText->new();
	$disk_selector[$i]->append_text("-- do not use --");
	$disk_selector[$i]->set_active(0);
 	foreach my $hd (@$hds) {
	    my ($disk, $devname, $size, $model) = @$hd;
	    $disk_selector[$i]->append_text(get_device_desc ($devname, $size, $model));
	    $disk_selector[$i]->{pve_disk_id} = $i;
	    $disk_selector[$i]->signal_connect (changed => sub {
		my $w = shift;
		my $diskid = $w->{pve_disk_id};
		my $a = $w->get_active - 1;
		$config_options->{"disksel${diskid}"} = ($a >= 0) ? $hds->[$a] : undef;
	    });
	}

	if ($hdopion_first_setup) {
	    $disk_selector[$i]->set_active ($i+1) if $hds->[$i];
	} else {
	    my $hdind = 0;
	    if (my $cur_hd = $config_options->{"disksel$i"}) {
		foreach my $hd (@$hds) {
		    if (@$hd[1] eq @$cur_hd[1]) {
			$disk_selector[$i]->set_active($hdind+1);
			last;
		    }
		    $hdind++;
		}

	    }
	}

	$grid->attach($disk_selector[$i], 1, $row, 1, 1);

	$row++;
    }

    $hdopion_first_setup = 0;

    my $label_hdsize = Gtk3::Label->new ("hdsize");
    $label_hdsize->set_alignment (1, 0.5);
    $grid->attach($label_hdsize, 0, $row, 1, 1);

    # size compute 
    my $hdsize = 0;
    if ( -b $target_hd) {
	$hdsize = int(hd_size ($target_hd) / (1024*1024.0)); # size in GB
    } elsif ($target_hd) {
	$hdsize = int((-s $target_hd) / (1024*1024*1024.0));
    }

    my $hdsize_size_adj = Gtk3::Adjustment->new($config_options->{hdsize} || $hdsize, 0, $hdsize+1, 1, 1, 1);
    my $spinbutton_hdsize = Gtk3::SpinButton->new($hdsize_size_adj, 1, 1);
    $spinbutton_hdsize->set_tooltip_text("only use specified size (GB) of the harddisk (rest left unpartitioned)");
    $grid->attach($spinbutton_hdsize, 1, $row, 1, 1);
    $row++;

    my $label_swapsize = Gtk3::Label->new ("swapsize");
    $label_swapsize->set_alignment (1, 0.5);
    $grid->attach($label_swapsize, 0, $row, 1, 1);

    my $entry_swapsize = Gtk3::Entry->new();
    $entry_swapsize->set_tooltip_text("maximum SWAP size (GB)");
    $entry_swapsize->signal_connect (key_press_event => \&check_float);
    $entry_swapsize->set_text($config_options->{swapsize}) if $config_options->{swapsize};
    $grid->attach($entry_swapsize, 1, $row, 1, 1);
    $row++;

    my $label_maxroot = Gtk3::Label->new ("maxroot");
    $label_maxroot->set_alignment (1, 0.5);
    $grid->attach($label_maxroot, 0, $row, 1, 1);

    my $entry_maxroot = Gtk3::Entry->new();
    $entry_maxroot->set_tooltip_text("maximum size (GB) for LVM root volume");
    $entry_maxroot->signal_connect (key_press_event => \&check_float);
    $entry_maxroot->set_text($config_options->{maxroot}) if $config_options->{maxroot};
    $grid->attach($entry_maxroot, 1, $row, 1, 1);
    $row++;

    my $label_minfree = Gtk3::Label->new ("minfree");
    $label_minfree->set_alignment (1, 0.5);
    $grid->attach($label_minfree, 0, $row, 1, 1);

    my $entry_minfree = Gtk3::Entry->new();
    $entry_minfree->set_tooltip_text("minumum free LVM space (GB, required for LVM snapshots)");
    $entry_minfree->signal_connect (key_press_event => \&check_float);
    $entry_minfree->set_text($config_options->{minfree}) if $config_options->{minfree};
    $grid->attach($entry_minfree, 1, $row, 1, 1);
    $row++;

    my $label_maxvz = Gtk3::Label->new ("maxvz");
    $label_maxvz->set_alignment (1, 0.5);
    $grid->attach($label_maxvz, 0, $row, 1, 1);

    my $entry_maxvz = Gtk3::Entry->new();
    $entry_maxvz->set_tooltip_text("maximum size (GB) for LVM data volume");
    $entry_maxvz->signal_connect (key_press_event => \&check_float);
    $entry_maxvz->set_text($config_options->{maxvz}) if $config_options->{maxvz};
    $grid->attach($entry_maxvz, 1, $row, 1, 1);
    $row++;

    my $set_sensitive_flag = sub {
	my $enable_size_hints = $config_options->{filesys} !~ m/zfs/;

	if ($config_options->{filesys} =~ m/zfs/) {
	    $target_hd_combo->set_visible(0);
	    $target_hd_label->set_text("Target: $config_options->{filesys} ");
	    foreach my $w (@disk_selector) { $w->set_visible(1); }
	    foreach my $w (@disk_label) { $w->set_visible(1); }
	} else {
	    $target_hd_combo->set_visible(1);
	    foreach my $w (@disk_selector) { $w->set_visible(0); }
	    foreach my $w (@disk_label) { $w->set_visible(0); }
	    $target_hd_label->set_text("Target Harddisk: ");
	}

	$spinbutton_hdsize->set_visible($enable_size_hints);
	$label_hdsize->set_visible($enable_size_hints);
	$entry_swapsize->set_visible($enable_size_hints);
	$label_swapsize->set_visible($enable_size_hints);
	$entry_maxroot->set_visible($enable_size_hints);
	$label_maxroot->set_visible($enable_size_hints);
	$entry_minfree->set_visible($enable_size_hints);
	$label_minfree->set_visible($enable_size_hints);
	$entry_maxvz->set_visible($enable_size_hints);
	$label_maxvz->set_visible($enable_size_hints);
    };

    &$set_sensitive_flag();

    $fstypecb->signal_connect (changed => sub {
	$config_options->{filesys} = $fstypecb->get_active_text();
	&$set_sensitive_flag();
    });

    $dialog->show();

    $dialog->run();

    my $get_float = sub {
	my ($entry) = @_;

	my $text = $entry->get_text();
	return undef if !defined($text);

	$text =~ s/^\s+//;
	$text =~ s/\s+$//;

	return undef if $text !~ m/^\d+(\.\d+)?$/;

	return $text;
    };

    my $tmp;

    if (($tmp = &$get_float($spinbutton_hdsize)) && ($tmp != $hdsize)) {
	$config_options->{hdsize} = $tmp;
    } else {
	delete $config_options->{hdsize};
    }

    if (defined($tmp = &$get_float($entry_swapsize))) {
	$config_options->{swapsize} = $tmp;
    } else {
	delete $config_options->{swapsize};
    }

    if (defined($tmp = &$get_float($entry_maxroot))) {
	$config_options->{maxroot} = $tmp;
    } else {
	delete $config_options->{maxroot};
    }

    if (defined($tmp = &$get_float($entry_minfree))) {
	$config_options->{minfree} = $tmp;
    } else {
	delete $config_options->{minfree};
    }

    if (defined($tmp = &$get_float($entry_maxvz))) {
	$config_options->{maxvz} = $tmp;
    } else {
	delete $config_options->{maxvz};
    }

    $dialog->destroy();
}

sub get_zfs_raid_setup {

    my $filesys = $config_options->{filesys};

    my $dev_name_hash = {};

    my $devlist = [];
    my $bootdevlist = [];
    for (my $i = 0; $i < 6; $i++) {
	if (my $hd = $config_options->{"disksel$i"}) {
	    my ($disk, $devname, $size, $model) = @$hd;
	    die "device '$devname' is used more than once\n" 
		if $dev_name_hash->{$devname};
	    $dev_name_hash->{$devname} = $hd;
	    push @$devlist, $hd;
	}
    }

    my $diskcount = scalar(@$devlist);
    die "$filesys need at least one device\n" if $diskcount < 1;

    my $cmd= '';
    if ($filesys eq 'zfs (RAID0)') {
	push @$bootdevlist, @$devlist[0];
	foreach my $hd (@$devlist) {
	    $cmd .= " @$hd[1]";
	}
    } elsif ($filesys eq 'zfs (RAID1)') {
	die "zfs (RAID1) need at least 2 device\n" if $diskcount < 2;
	$cmd .= ' mirror ';
	my $hd = @$devlist[0];
	my $expected_size = @$hd[2]; # all disks needs same size
	foreach $hd (@$devlist) {
	    die "mirrored disks must have same size\n" if @$hd[2] != $expected_size;
	    $cmd .= " @$hd[1]";
	    push @$bootdevlist, $hd;
	}
    } elsif ($filesys eq 'zfs (RAID10)') {
	my $half = int($diskcount/2);
	die "zfs (RAID10) need at least 4 device\n" if $diskcount < 4;
	die "zfs (RAID10) need at an even numver of devices\n" if $half*2 != $diskcount;
	
	push @$bootdevlist, @$devlist[0], @$devlist[1];

	for (my $i = 0; $i < $diskcount; $i+=2) {
	    my $hd1 = @$devlist[$i];
	    my $hd2 = @$devlist[$i+1];
	    die "mirrored disks must have same size\n" if @$hd1[2] != @$hd2[2];
	    $cmd .= ' mirror ' . @$hd1[1] . ' ' . @$hd2[1];
	}

    } elsif ($filesys =~ m/^zfs \(RAIDZ-([123])\)$/) {
	my $level = $1;
	my $mindisks = 2 + $level;
	die "zfs (RAIDZ-$level) need at least $mindisks devices\n" if scalar(@$devlist) < $mindisks;
	my $hd = @$devlist[0];
	my $expected_size = @$hd[2]; # all disks needs same size
	$cmd .= " raidz$level";
	foreach $hd (@$devlist) {
	    die "mirrored disks must have same size\n" if @$hd[2] != $expected_size;
	    $cmd .= " @$hd[1]";
	    push @$bootdevlist, $hd;
	}
    } else {
	die "unknown zfs mode '$filesys'\n";
    }

    return ($devlist, $bootdevlist, $cmd);
}

sub create_hdsel_view {

    cleanup_view ();

    my $vbox =  Gtk3::VBox->new (0, 0);
    $inbox->pack_start ($vbox, 1, 0, 0);
    my $hbox =  Gtk3::HBox->new (0, 0);
    $vbox->pack_start ($hbox, 0, 0, 10);

    my ($disk, $devname, $size, $model) = @{@$hds[0]};
    $target_hd = $devname;

    $target_hd_label = Gtk3::Label->new ("Target Harddisk: ");
    $hbox->pack_start ($target_hd_label, 0, 0, 0);

    $target_hd_combo = Gtk3::ComboBoxText->new();

    foreach my $hd (@$hds) {
	($disk, $devname, $size, $model) = @$hd;
	$target_hd_combo->append_text (get_device_desc ($devname, $size, $model));
    }

    $target_hd_combo->set_active (0);
    $target_hd_combo->signal_connect (changed => sub {
	$a = shift->get_active;
	my ($disk, $devname) = @{@$hds[$a]};
	$target_hd = $devname;
    });
    
    $hbox->pack_start ($target_hd_combo, 0, 0, 10);

    my $options = Gtk3::Button->new ('_Options');
    $options->signal_connect (clicked => \&create_hdoption_view);
    $hbox->pack_start ($options, 0, 0, 0);


    $inbox->show_all;

    display_html ("page1.htm");

    set_next (undef, sub {

	if ($config_options->{filesys} =~ m/zfs/) {
	    eval { get_zfs_raid_setup(); };
	    if (my $err = $@) {
		display_message ("Warning: $err\n" .
				 "Please fix ZFS setup first.");
	    } else {
		create_country_view();
	    }
	} else {
	    create_country_view();
	}
    });
}

sub create_extract_view {

    cleanup_view ();

    display_html ("extract1-license.htm");
    $next->set_sensitive (0);

    my $vbox =  Gtk3::VBox->new (0, 0);
    $inbox->pack_start ($vbox, 1, 0, 0);
    my $hbox =  Gtk3::HBox->new (0, 0);
    $vbox->pack_start ($hbox, 0, 0, 10);

    my $vbox2 =  Gtk3::VBox->new (0, 0);
    $hbox->pack_start ($vbox2, 0, 0, 0);

    $progress_status = Gtk3::Label->new ('');
    $vbox2->pack_start ($progress_status, 1, 1, 0);

    $progress = Gtk3::ProgressBar->new;
    $progress->set_show_text(1);
    $progress->set_size_request (600, -1);

    $vbox2->pack_start ($progress, 0, 0, 0);

    $inbox->show_all;

    my $tdir = $opt_testmode ? "target" : "/target";
    mkdir $tdir;
    my $base = $opt_testmode ? "/pve/$release/install/pve-base.tar" : "/proxmox/pve-base.tar";

    eval  { extract_data ($base, $tdir); };
    my $err = $@;

    $next->set_sensitive (1);

    set_next ("_Reboot", sub { exit (0); } );

    if ($err) {
	display_html ("fail.htm");
	display_error ($err);
    } else {
	cleanup_view ();
	display_html ("success.htm");
    }
}

sub create_intro_view {

    cleanup_view ();

    display_html ("license.htm");

    set_next ("I a_gree", \&create_hdsel_view);
}

$ipconf = get_ip_config ();

$country = detect_country() if $ipconf->{addr} || $opt_testmode;;

# read country, kmap and timezone infos
$cmap = read_cmap ();

create_main_window ();

if (!defined ($hds) || (scalar (@$hds) <= 0)) {
    print "no hardisks found\n";
    display_html ("nohds.htm");
    set_next ("Reboot", sub { exit (0); } );
} else {

    foreach my $hd (@$hds) {
	my ($disk, $devname) = @$hd;
	next if $devname =~ m|^/dev/md\d+$|;
	print "found Disk$disk N:$devname\n";
    }

    create_intro_view ();
}

Gtk3->main;

exit 0;
